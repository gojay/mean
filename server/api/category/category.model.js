'use strict';

var mongoose = require('mongoose'),
    Schema = mongoose.Schema;

var tree = require('mongoose-path-tree');
var async = require('async');

var _  = require('lodash');
// Import Underscore.string to separate object, because there are conflict functions (include, reverse, contains)
_.str = require('underscore.string');
// Mix in non-conflict functions to Underscore namespace if you want
_.mixin(_.str.exports());

var CategorySchema = new Schema({
    _id: {
        type: String,
        trim: true,
        lowercase: true,
        set: function(id) { 
          return _.slugify(id);
        }
    },
    name: {
      type: String,
      set: function(name) {
        return _.titleize(name);
      }
    },
    count: {
      type: Number,
      default: 0
    }
});

CategorySchema.plugin(tree, {
  pathSeparator : '/',              // Default path separator
  onDelete      : 'REPARENT',       // Can be set to 'DELETE' or 'REPARENT'. Default: 'REPARENT'
  numWorkers    : 5,                // Number of stream workers
  idType        : String            // Type used for _id. Can be, for example, String generated by shortid module
});

var statics = {

  getPathDescendants: function (fields, cb) {
    var self = this;

    if(_.isString(fields)) {
      fields = [fields];
    }

    fields = fields.map(function (str) {
      return str.toLowerCase();
    });

    var descendants = [];
    this.find({_id:{ $in:fields }}, function (err, categories) {
      // create criteria from path
      var criteria = categories.map(function (category) {
        return '^'+category.path+'/';
      }).join('|');
      // find path regex
      self.find({path: { $regex: criteria, $options: 'i' }}, function (err, categories) {
        // get decsendants
        async.each(categories, function(category, done) {
          descendants.push(category._id);
          done(err);
        }, function(err, r) {
          if(err) cb(err);
          cb(err, descendants);
        });
      });
    });
  },

  setCount: function(data, done) {
    var self = this;

    var category = data.category;
    var value = data.value;

    this.findOne({ _id:category }, function(err, _category) {
      if(err) { done(err); }

      _category.getAncestors({}, "_id", function (err, categories) {
        if(err) { done(err); }

        var paths = categories.map(function(item){ 
          return item._id; 
        });

        paths.push(category);

        var conditions = { _id: { $in:paths } },
            doc        = { $inc: { count:value } },
            options    = { multi: true };
        self.update(conditions, doc, options, function(err, result) { 
          if (err) {
            done(err);
          }
          done(null, result);
        });
      });
    });

  },

  // getListCount: function(cb) {
  //   var self = this;
  //   this.find({}, function (err, categories) {
  //     async.map(categories, function (category, done) {
  //       self.getPathDescendants(category._id, function(err, descendants) {
  //         var _in = !_.isEmpty(descendants) ? descendants : [category._id];
  //         Blog.count({ category: { $in:_in } }, function (err, count) {
  //           if(err) done(err);
  //           var data = {
  //             id: category._id,
  //             count: count
  //           };
  //           done(null, data);
  //         });
  //       });
  //     }, cb);
  //   });
  // }

};

_.extend(CategorySchema.statics, statics);

module.exports = mongoose.model('Category', CategorySchema);